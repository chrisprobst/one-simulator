MAINFILE = ENV['MAIN'] ? ENV['MAIN'] : 'master.tex'
FINALFILE = 'final.tex'
BOOKLETPSFILE = 'booklet.ps'
BOOKLETPSFILE = "booklet-#{ENV["pages"]}.ps" if ENV["pages"]
CONFERENCEEXPRESSFILE = 'conferenceexpress.tar.gz'
BIBTEX_OPTIONS = '-min-crossrefs=10000'

MAXRUNS = 4
MAXRUNS = 1 if Rake.application.top_level_tasks.include?("once")
Rake.application.top_level_tasks.delete("once")
Rake.application.top_level_tasks << "default" if Rake.application.top_level_tasks.empty?
MAXRUNS = ENV["maxruns"].to_i if ENV["maxruns"]


task :default => :pdf

desc "Generate DVI"
task :dvi => MAINFILE.ext("dvi")

desc "Generate PostScript"
task :ps => MAINFILE.ext("ps")

desc "Generate 2-up PostScript booklet; for certain pages, use e.g. 'rake booklet pages=40-80,85,87'"
task :booklet => BOOKLETPSFILE

desc "Generate gzipped PostScript"
task :psgz => MAINFILE.ext("ps.gz")

desc "Generate PDF"
task :pdf => MAINFILE.ext("pdf")

desc "Generate Quick'n'Dirty PDF"
task :once => MAINFILE.ext("pdf")

desc "Generate #{FINALFILE}, where all LaTeX sources are combined and comments are stripped"
#task :final => FINALFILE
task :final => [FINALFILE, FINALFILE.ext("pdf"), FINALFILE.ext("ps")]

desc "Generate a tar.gz file that can be directly submitted"
task :tar => "final_submission.tar.gz"

desc "Build tarball for final submission to IEEE Conference eXpress (includes dvi + eps figures)"
task :conferenceexpress => CONFERENCEEXPRESSFILE

desc "Generate all targets"
task :all => [:dvi, :ps, :psgz, :pdf, :final, :tar, :conferenceexpress]


require 'digest/md5'


file MAINFILE

@commondeps = [MAINFILE]
@dvideps = []
@pdfdeps = []
@makeindexdeps = []

@cleanfiles = []

@warnings = 0
@drafts = 0

@bibtex_used = false
@thumbpdf_used = false
@nomenclature_used = false
@index_used = false
@letterpaper_used = false
@inkscape_text_embed_problem = false
@inkscape_directpdf = (ENV["directpdf"] == nil || ENV["directpdf"].to_i == 1)
@inkscape_texttopath = (ENV["texttopath"] == nil || ENV["texttopath"].to_i == 1)
@embed_files = Array.new



class String

  def dirname
    File.dirname(self)
  end

  def basename
    File.basename(self)
  end

  def indir(path)
    path == "" || path == "."  ?  self  :  path + "/" + self
  end

end


def extract_deps(line, prefix = "")

  if m = /(.*?)\\(include|input)\{([a-zA-Z0-9_\-\.\/]+)\}(.*)/.match(line)                        # Included LaTeX source
    extract_deps(m[1], prefix)

    # is this TeX file generated by the diagraph preprocessor?
    dgrfile = m[3].ext("dgr")
    if File.exists?(dgrfile)
      puts "#{prefix}  #{dgrfile} (diagraph block chart definition)"

      file m[3].ext("tex") => m[3].ext("dgr") do
	sh "diagraph #{m[3].ext("dgr")}"
      end

      @cleanfiles.push(m[3].ext("tex"))

      @commondeps.push(m[3].ext("tex"))

    else
      # user generated TeX file => parse recursively
      @commondeps.push(m[3].indir(MAINFILE.dirname).ext("tex"))
      generate_deps_for_latex(m[3].indir(MAINFILE.dirname).ext("tex"), prefix + "  ")
    end

    extract_deps(m[4], prefix)

  elsif m = /(.*?)\\documentclass(\[[^\]]+\])?\{([a-zA-Z0-9_\-\.]+)\}(.*)/.match(line)            # Document class definition
    extract_deps(m[1], prefix)
    @letterpaper_used = true if n = /.*letterpaper.*/.match(m[2])
    clsfile = m[3].ext("cls")
    if File.exists?(clsfile)
      puts "#{prefix}  #{clsfile} (LaTeX document class)"
      file clsfile
      @commondeps.push(clsfile)
    end
    extract_deps(m[4], prefix)

  elsif m = /(.*?)\\usepackage(\[[^\]]+\])?\{([a-zA-Z0-9_\-\.\,]+)\}(.*)/.match(line)             # included LaTeX package
    extract_deps(m[1], prefix)
    m[3].split(/\s*,\s*/).each do |p|
      packagefile = p.ext("sty")
      if File.exists?(packagefile)
        puts "#{prefix}  #{packagefile} (LaTeX package)"
        file packagefile
        @commondeps.push(packagefile)
      end
    end
    extract_deps(m[4], prefix)

  elsif m = /(.*?)\\bibliographystyle(\[[^\]]+\])?\{([a-zA-Z0-9_\-\.\/]+)\}(.*)/.match(line)      # BibTeX style
    extract_deps(m[1], prefix)
    bstfile = m[3].ext("bst")
    if File.exists?(bstfile)
      puts "#{prefix}  #{bstfile} (BibTeX bibliography style)"
      file bstfile
      @commondeps.push(bstfile)
    end
    extract_deps(m[4], prefix)

  elsif m = /(.*?)\\includegraphics(\<[0-9\-\+]+\>)?(\[[^\]]+\])?\{([a-zA-Z0-9_\-\.\/]+)\}(.*)/.match(line)         # Figure
    extract_deps(m[1], prefix)
    process_figure_deps(m[4], prefix)
    extract_deps(m[5], prefix)

  elsif m = /(.*?)\\multiinclude(\[[^\]]+\])?\{([a-zA-Z0-9_\-\.\/]+)\}(.*)/.match(line)         	   # multiinclude in LaTeX Beamer
    # \multiinclude[format=pdf,graphics={width=\textwidth},<+>]{fig/zeitverlauf/projektverlauf_zeit}

    extract_deps(m[1], prefix)
    index = 0
    puts "#{prefix}  #{m[3]} (multiinclude graphics)"
    while !Dir["#{m[3]}-#{index}.*"].empty?
      process_figure_deps("#{m[3]}-#{index}", prefix)
      index += 1
    end
    extract_deps(m[4], prefix)

  elsif m = /(.*?)\\bibliography\{([a-zA-Z0-9_\-\.\/\, ]+)\}(.*)/.match(line)                      # BibTeX data
    extract_deps(m[1], prefix)
    bibfiles = m[2].split(/\s*,\s*/).collect { |bibfile|  bibfile.ext("bib") }
    bibfiles.each do |bibfile|
      puts "#{prefix}  #{bibfile} (BibTeX bibliography)"
      file bibfile
      if(bibfile =~ /(.*)-short.bib/)
        create_short_bib($1)
      end
      @commondeps.push(bibfile)
    end
    extract_deps(m[3], prefix)

  elsif m = /(.*?)\\cite\{[^\}]+\}(.*)/.match(line)                                                # Citation
    extract_deps(m[1], prefix)
    if not @bibtex_used
      puts "#{prefix}  Citation detected => BibTeX used"
      @bibtex_used = true
    end
    extract_deps(m[2], prefix)

  elsif m = /(.*?)\\usepackage\{[^\}]*\bthumbpdf\b[^\}]*\}(.*)/.match(line)                                                # Citation
    extract_deps(m[1], prefix)
    if not @thumbpdf_used
      puts "#{prefix}  Thumbpdf package detected"
      @thumbpdf_used = true
    end
    extract_deps(m[2], prefix)

  elsif m = /(.*?)\\draft[ano]*?\{(.*)/.match(line)                                                # Draft
    extract_deps(m[1], prefix)
    puts "#{prefix}  WARNING: draft comment inside the text"
#   @warnings += 1
    @drafts += 1
    extract_deps(m[2], prefix)

  elsif m = /(.*?)[^%]*\\printnomenclature(.*)/.match(line)   					# Nomenclature
    extract_deps(m[1], prefix)
    if not @nomenclature_used
      puts "#{prefix}  Nomenclature detected => MakeIndex with nomencl.ist used"
      @nomenclature_used = true
      @makeindexdeps << "nomencl.ist"
    end
    extract_deps(m[2], prefix)

  elsif m = /(.*?)[^%]*\\index\{[^\}]*\}(.*)/.match(line)   					# Index
    extract_deps(m[1], prefix)
    if not @index_used
      puts "#{prefix}  Index detected => MakeIndex with index.ist used"
      @index_used = true
      @makeindexdeps << "index.ist"
    end
    extract_deps(m[2], prefix)

#  elsif m = /(.*?)\\draftanno\{(.*)/.match(line)                                                # Draft
#    extract_deps(m[1], prefix)
#    puts "#{prefix} WARNING: draft comment inside the text"
##   @warnings += 1
#    @drafts += 1
#    extract_deps(m[2], prefix)

  end

end


def epstopdf_task(figname)                                # Generate a task to convert eps image to PDF (for pdflatex)
  file figname.ext("pdf") => figname.ext("eps") do
#    sh "ps2pdf -dPDFSETTINGS=/prepress -dAutoFilterColorImages=false -dColorImageFilter=/FlateEncode #{figname.ext("eps")} #{figname.ext("pdf")}"
#    sh "epstopdf #{figname.ext("eps")}"
     sh "epstopdf --nogs --outfile=#{figname.ext("tmp.eps")} #{figname.ext("eps")} || true"
     sh "gs -q -sDEVICE=pdfwrite -dPDFSETTINGS=/prepress -dCompatibilityLevel=1.4 -dAutoRotatePages=/None -sOutputFile=#{figname.ext("pdf")} - -c quit < #{figname.ext("tmp.eps")} || true"
     File.delete(figname.ext("tmp.eps")) if File.exists?(figname.ext("tmp.eps"))
  end
  @cleanfiles.push(figname.ext("pdf"))
end


def process_figure_deps(figname, prefix = "")

  if File.exists?(figname.ext("jpg"))                                # JPEG
    puts "#{prefix}  #{figname.ext("jpg")} (JPEG image)"

    file figname.ext("eps") => figname.ext("jpg") do
      sh "convert #{figname.ext("jpg")} #{figname.ext("eps")}"
    end

    @cleanfiles.push(figname.ext("eps"))

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("jpg"))

  elsif File.exists?(figname.ext("png"))                             # PNG
    puts "#{prefix}  #{figname.ext("png")} (PNG image)"

    file figname.ext("eps") => figname.ext("png") do
      sh "convert #{figname.ext("png")} #{figname.ext("eps")}"
    end

    @cleanfiles.push(figname.ext("eps"))

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("png"))

  elsif File.exists?(figname.ext("bmp"))                             # BMP
    puts "#{prefix}  #{figname.ext("bmp")} (BMP image)"

    file figname.ext("eps") => figname.ext("bmp") do
      sh "convert #{figname.ext("bmp")} #{figname.ext("eps")}"
    end

    @cleanfiles.push(figname.ext("eps"))
    epstopdf_task figname

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("pdf"))

  elsif File.exists?(figname.ext("svg"))                          # Inkscape SVG

    puts "#{prefix}  #{figname.ext("svg")} (SVG image)"

    if @inkscape_directpdf                                        # directly create svg->pdf without eps step in between

      file figname.ext("pdf") => figname.ext("svg") do
        File.delete(figname.ext("pdf")) if File.exists?(figname.ext("pdf"))
        sh %{inkscape #{@inkscape_texttopath?"--export-text-to-path ":""}--export-area-drawing --export-pdf=#{figname.ext("pdf")} #{figname.ext("svg")} 2>&1 || true}
      end

      @cleanfiles.push(figname.ext("log"))
      @cleanfiles.push(figname.ext("pdf"))
      @pdfdeps.push(figname.ext("pdf"))

    else

      file figname.ext("eps") => figname.ext("svg") do
        File.delete(figname.ext("eps")) if File.exists?(figname.ext("eps"))
        sh %{inkscape #{@inkscape_texttopath?"--export-text-to-path ":""}--export-area-drawing --export-eps=#{figname.ext("eps")} #{figname.ext("svg")} 2>&1 || true}
      end

      @cleanfiles.push(figname.ext("log"))
      @cleanfiles.push(figname.ext("eps"))
      epstopdf_task figname

      @dvideps.push(figname.ext("eps"))
      @pdfdeps.push(figname.ext("pdf"))

    end

  elsif File.exists?(figname.ext("svgz"))                          # Gzipped Inkscape SVG
    puts "#{prefix}  #{figname.ext("svgz")} (Gzipped SVG image)"

    file figname.ext("eps") => figname.ext("svgz") do
      File.delete(figname.ext("eps")) if File.exists?(figname.ext("eps"))
      sh %{inkscape --export-embed-fonts --export-area-drawing --export-eps=#{figname.ext("eps")} #{figname.ext("svgz")} 2>&1 || true}
#      sh %{inkscape --export-embed-fonts --export-eps=#{figname.ext("eps")} #{figname.ext("svgz")} > #{figname.ext("log")} 2>&1}
#      sh %{grep "canceled for font" #{figname.ext("log")}} do |font_problem, grep_return|
#        sh %{test ! -f #{figname.ext("eps")}} do |inkscape_problem, test_return|
#          if font_problem || inkscape_problem
#            sh %{inkscape --export-text-to-path --export-eps=#{figname.ext("eps")} #{figname.ext("svg")}}
#	    @inkscape_text_embed_problem = true
#	    @embed_files.push(figname.ext("svgz"))
#	  end
#	end
#      end
    end

    @cleanfiles.push(figname.ext("log"))
    @cleanfiles.push(figname.ext("eps"))
    epstopdf_task figname

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("pdf"))

  elsif File.exists?(figname.ext("dot"))                             # GraphViz dot
    puts "#{prefix}  #{figname.ext("dot")} (GraphViz dot graph description)"

    file figname.ext("eps") => figname.ext("dot") do
      sh "dot -Tps2 -Gcharset=latin1 -o #{figname.ext("eps")} #{figname.ext("dot")}"
    end

    @cleanfiles.push(figname.ext("eps"))
    epstopdf_task figname

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("pdf"))

  elsif File.exists?(figname.ext("neato"))                             # GraphViz neato
    puts "#{prefix}  #{figname.ext("neato")} (GraphViz neato graph description)"

    file figname.ext("eps") => figname.ext("neato") do
      sh "neato -Tps2 -o #{figname.ext("eps")} #{figname.ext("neato")}"
    end

    @cleanfiles.push(figname.ext("eps"))
    epstopdf_task figname

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("pdf"))

  elsif File.exists?(figname.ext("gpl"))                             # Gnuplot
    puts "#{prefix}  #{figname.ext("gpl")} (Gnuplot graph file)"

    # extract dependencies from gpl file
    gpldeps = generate_deps_for_gnuplot(figname.ext("gpl"), prefix + "  ")

    file figname.ext("eps") => [figname.ext("gpl")] + gpldeps do
      sh "cd #{File.dirname(figname)} && gnuplot #{File.basename(figname).ext("gpl")}"
    end

    @cleanfiles.push(figname.ext("eps"))
    epstopdf_task figname

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("pdf"))

  elsif File.exists?(figname.ext("fig"))                             # xfig
    puts "#{prefix}  #{figname.ext("fig")} (xfig drawing)"

    file figname.ext("eps") => figname.ext("fig") do
      sh "fig2dev -L eps #{figname.ext("fig")} #{figname.ext("eps")}"
    end

    @cleanfiles.push(figname.ext("eps"))
    epstopdf_task figname

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("pdf"))

  elsif File.exists?(figname.ext("dia"))                             # dia
    puts "#{prefix}  #{figname.ext("dia")} (Dia technical diagram)"

    file figname.ext("eps") => figname.ext("dia") do
      # 2012-01-09 koegel: '-t eps-builtin' causes problems with text positions, '-t eps' fixes the problem (reported by Evgeni Golov)
      # sh "dia #{figname.ext("dia")} -nt eps-builtin"
      sh "dia #{figname.ext("dia")} -nt eps -e #{figname.ext("eps")}"
    end

    @cleanfiles.push(figname.ext("eps"))
    epstopdf_task figname

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("pdf"))

  elsif File.exists?(figname.ext("eps"))                            # only EPS found
    puts "#{prefix}  WARNING: No source file(s) for figure #{figname} could be found. Only the EPS file will be included!"
    @warnings += 1

    epstopdf_task figname

    @dvideps.push(figname.ext("eps"))
    @pdfdeps.push(figname.ext("pdf"))

  else
    puts "#{prefix}  WARNING: No file(s) for figure #{figname} could be found. It will NOT be included in the dependencies!"
    @warnings += 1

  end

end


def generate_deps_for_gnuplot(gplfile, prefix = "")          # find data file references of a Gnuplot graph

  deps = []
  File.open(gplfile).each_line do |line|
    if m = /^\s*[s]?plot\s+[\"\']([^\"\']+)[\"\'].*/.match(line) || m = /^\s*[\"\']([^\"\']+)[\"\'].*/.match(line)
      datafile = m[1].indir(gplfile.dirname)
      next if deps.include?(datafile)
      if(m[1] == "-")
        puts "#{prefix} No separate gnuplot data file"
        next
      end
      puts "#{prefix}  #{datafile} (Gnuplot data file)"
      deps.push(datafile)
    end
  end

  return deps

end


def generate_deps_for_latex(texfile, prefix = "")

  puts "#{prefix}#{texfile} (LaTeX source)"

  File.open(texfile).each_line do |line|

    l = line

    # remove comments
    l.gsub!('\\\\', '')
    l.gsub!('\\%', '')
    l.gsub!(/%.*/, '')

    extract_deps(l, prefix)

  end

end

# method to copy all included files in one single file and strip the comments
def integrate_file(filename, bblfile, nomenclaturefile, indexfile)
  content = ''
  begin
    File.open(filename, 'r') do |file|
      file.readlines.each do |line|

        # delete the comments
        line = line.gsub(/([^\\]%).*/, '\1').gsub(/^%.*\n/, '')

        # if the latexfile has an input, then call the integrate_file-methode for this file
        if (md = line.match(/^(.*?)\\input\{([^\}]+)\}(.*?)/))
          if (md[2] =~ /^(.*?)tex/)
            input_file = md[2].concat("")  # if the inputfile has the ending ".tex" then don't change it
          else
            input_file = md[2].concat(".tex") # else concat the ending ".tex" on it
          end
          content += md[1] + integrate_file(input_file, bblfile, nomenclaturefile, indexfile) + md[3]

        # remove any bibliographystyle command
	elsif (md = line.match(/^(.*?)\\bibliographystyle\{[^\}]+\}(.*?)/))
          content += md[1] + md[2]

        # replace bibliography command by Bibtex' output (from ***master.bbl***, because final.bbl won't yet exist)
        # note: therefore final.tex depends on master.dvi or master.pdf!
        elsif (md = line.match(/^(.*?)\\bibliography\{[^\}]+\}(.*?)/))
          content += md[1] + "\n"
          content += File.open(bblfile, 'r').read + "\n" if bblfile     # bblfile might not be defined if the document doesn't use BibTeX
          content += md[2]

        # replace printnomenclature by makeindex nomencl output
        # note: therefore final.tex depends on master.dvi or master.pdf!
        # assuming that printnomenclature is alone in a single line, to avoid problems with optional arguments; guess that will typically hold...
        elsif (md = line.match(/^\s*\\printnomenclature.*/))
          content += File.open(nomenclaturefile, 'r').read + "\n" if nomenclaturefile     # nomenclaturefile might not be defined if the document doesn't use nomencl

        # replace printindex by makeindex output
        # note: therefore final.tex depends on master.dvi or master.pdf!
        # assuming that printindex is alone in a single line, to avoid problems with optional arguments; guess that will typically hold...
        elsif (md = line.match(/^\s*\\printindex.*/))
          content += File.open(indexfile, 'r').read + "\n" if indexfile     # indexfile might not be defined if the document doesn't use index

        else
          content += line
        end

      end
    end

  rescue SystemCallError
    $stderr.print "IO failed: " + $!
    raise
  end
  return content
end

# creates a version of the bibtex file in which the conference names are shortened, i.e.
# {MobiCom~'04: Proceedings of the 10th Annual ACM International Conference on Mobile Computing and Networking}
# will become {MobiCom~'04}
def create_short_bib(long_version_filename)
  file (long_version_filename + "-short.bib") => long_version_filename.ext(".bib") do
    in_file = File.open(long_version_filename.ext(".bib"), "r")
    out_file = File.open((long_version_filename+"-short.bib"), "w")

    paranthesis_missing = false
    in_file.each_line do |line|
      if(paranthesis_missing == true)
        # handles the case in which the conference name is spread over multiple
        # lines: in this case all lines until the first occurence of "}," at
        # the end of the line will be discarded
        line =~ /.*(\},)/
        if($1.nil?())
          paranthesis_missing = true
        else
          paranthesis_missing = false
        end
        next
      end
      if(line =~ /(.*booktitle = \{[^:]*).*/)
        out_file.puts $1 + "},"
        if(line =~ /(.*booktitle = \{[^:]*).*(\},)/)
          # the finishing paranthesis is there: we are happy
        else
          # the paranthesis is missing: switch to MISSING mode
          paranthesis_missing = true
        end
      else
        out_file.puts line
      end
    end

    out_file.close()
  end
end

def check_for_overfull_lines(filename)
  msg = ''
  sh %{egrep "Overfull.*hbox" #{filename.ext("log")}} do |found, res|
    if found
      msg = "---------------------------------\nWARNING: Overfull \\hbox found!!!\n---------------------------------"
    end
  end
  return msg
end


puts "------------------------------"
puts "  Extracting dependencies..."
puts "------------------------------"
generate_deps_for_latex(MAINFILE)
puts "------------------------------"
if @warnings > 0
  puts "THERE WERE #{@warnings} WARNINGS"
  puts "------------------------------"
end
if @drafts > 0
  puts "THERE WERE #{@drafts} draft WARNINGS"
  puts "------------------------------"
end


file MAINFILE.ext("dvi") => @commondeps + @dvideps + @makeindexdeps do
  File.delete(MAINFILE.ext("bbl")) if File.exists?(MAINFILE.ext("bbl")) and @bibtex_used
  File.delete(MAINFILE.ext("nls")) if File.exists?(MAINFILE.ext("nls")) and @nomenclature_used
  File.delete(MAINFILE.ext("idx")) if File.exists?(MAINFILE.ext("idx")) and @index_used

  sh "latex #{MAINFILE}"

  sh "bibtex #{BIBTEX_OPTIONS} #{MAINFILE.ext('')}" if @bibtex_used

  md5 = nil
  counter = 1
  until (File.exists?(MAINFILE.ext("dvi")) and (md5 == (md5 = Digest::MD5.digest(File.open(MAINFILE.ext("dvi")).read)))) or (counter >= MAXRUNS)
    counter += 1
    sh "makeindex #{MAINFILE.ext("nlo")} -s nomencl.ist -o #{MAINFILE.ext("nls")}" if @nomenclature_used
    sh "makeindex -s index.ist #{MAINFILE.ext('')}" if @index_used
    sh "latex #{MAINFILE}"
  end
  if md5 != Digest::MD5.digest(File.open(MAINFILE.ext("dvi")).read)
    puts "MD5 hash of DVI file still changes, giving up..."
  end
  msg = check_for_overfull_lines(MAINFILE)
  puts msg if msg
  if @inkscape_text_embed_problem
    puts "Some fonts in svg files could not be embedded, hence included as path"
    @embed_files.each do |e|
      puts "  - #{e}"
    end
  end
end


file MAINFILE.ext("ps") => MAINFILE.ext("dvi") do
  if @letterpaper_used then
    sh "dvips -t letter -o #{MAINFILE.ext("ps")} #{MAINFILE.ext("dvi")}"
  else
    sh "dvips #{MAINFILE.ext("dvi")} -o #{MAINFILE.ext("ps")}"
  end
end


file MAINFILE.ext("ps.gz") => MAINFILE.ext("ps") do
  sh "gzip -c #{MAINFILE.ext("ps")} > #{MAINFILE.ext("ps.gz")}"
end


file MAINFILE.ext("pdf") => @commondeps + @pdfdeps + @makeindexdeps do
  File.delete(MAINFILE.ext("bbl")) if File.exists?(MAINFILE.ext("bbl")) and @bibtex_used
  File.delete(MAINFILE.ext("nls")) if File.exists?(MAINFILE.ext("nls")) and @nomenclature_used
  File.delete(MAINFILE.ext("idx")) if File.exists?(MAINFILE.ext("idx")) and @index_used

  sh "pdflatex #{MAINFILE}"

  sh "bibtex #{BIBTEX_OPTIONS} #{MAINFILE.ext('')}" if @bibtex_used

  sh "thumbpdf #{MAINFILE.ext("pdf")}" if @thumbpdf_used

  md5 = nil
  counter = 1
  until (md5 == (md5 = Digest::MD5.digest(File.open(MAINFILE.ext("pdf")).read))) or (counter >= MAXRUNS)
    counter += 1
    sh "makeindex #{MAINFILE.ext("nlo")} -s nomencl.ist -o #{MAINFILE.ext("nls")}" if @nomenclature_used
    sh "makeindex -s index.ist #{MAINFILE.ext('')}" if @index_used
    sh "pdflatex #{MAINFILE}"
  end
  if md5 != Digest::MD5.digest(File.open(MAINFILE.ext("pdf")).read)
    puts "MD5 hash of PDF file still changes after maximum number of LaTeX runs, giving up..."
  end
  msg = check_for_overfull_lines(MAINFILE)
  puts msg if msg
  if @inkscape_text_embed_problem
    puts "Some fonts in svg files could not be embedded, hence included as path"
    @embed_files.each do |e|
      puts "  - #{e}"
    end
  end
end


file BOOKLETPSFILE => MAINFILE.ext("ps") do
  if ENV["pages"]
    pages = ENV["pages"]
    pages.gsub!(/\s/, "")
    sh "psselect #{pages} #{MAINFILE.ext("ps")} | psbook | psnup -2 | pstops \"2:0,1U(1w,1h)\" > #{BOOKLETPSFILE}"
  else
    sh "psbook #{MAINFILE.ext("ps")} | psnup -2 | pstops \"2:0,1U(1w,1h)\" > #{BOOKLETPSFILE}"
  end
end



file "#{FINALFILE.ext('pdf')}" => @pdfdeps + ["#{FINALFILE}"] do

  sh "pdflatex #{FINALFILE}"
  if @thumbpdf_used
    sh "pdflatex #{FINALFILE}"
    sh "thumbpdf #{FINALFILE}"
  end
  md5 = nil
  counter = 1
  until (md5 == (md5 = Digest::MD5.digest(File.open(FINALFILE.ext("pdf")).read))) or (counter >= MAXRUNS)
    counter += 1
    sh "pdflatex #{FINALFILE}"
  end
  if md5 != Digest::MD5.digest(File.open(FINALFILE.ext("pdf")).read)
    puts "MD5 hash of finalized PDF file still changes, giving up..."
  end
  msg = check_for_overfull_lines(FINALFILE)
  puts msg if msg
end

file FINALFILE.ext("ps") => FINALFILE.ext("dvi") do
  if @letterpaper_used then
    sh "dvips -t letter -o #{FINALFILE.ext("ps")} #{FINALFILE.ext("dvi")}"
  else
    sh "dvips #{FINALFILE.ext("dvi")} -o #{FINALFILE.ext("ps")}"
  end
end

file "final_submission.tar.gz" => @commondeps + @dvideps + [:compare] do
  relevant_files = @dvideps
  relevant_files.push("#{FINALFILE}")
  relevant_string = ""
  relevant_files.each {|element|
    relevant_string += element + " "
  }
#  puts relevant_string
  puts "------------------------------------------------"
  puts "| Building tarball, included files are listed  |"
  puts "------------------------------------------------"
  sh "tar -cvzf final_submission.tar.gz #{relevant_string}"
end


file "#{FINALFILE}" => @commondeps + @dvideps + ["#{MAINFILE.ext("dvi")}"] do
  content = integrate_file(MAINFILE.ext("tex"), @bibtex_used ? MAINFILE.ext("bbl") : nil, @nomenclature_used ? MAINFILE.ext("nls") : nil, @index_used ? MAINFILE.ext("ind") : nil)
  FL = File.new(FINALFILE.ext("tex"),"w+")
  FL << content
  FL.close()
end


file FINALFILE.ext("dvi") => @commondeps + @dvideps  + ["#{FINALFILE}"] do
  sh "latex #{FINALFILE}"
  md5 = nil
  counter = 1
  until (File.exists?(FINALFILE.ext("dvi")) and (md5 == (md5 = Digest::MD5.digest(File.open(FINALFILE.ext("dvi")).read)))) or (counter >= MAXRUNS)
    counter += 1
    sh "latex #{FINALFILE}"
  end
  if md5 != Digest::MD5.digest(File.open(FINALFILE.ext("dvi")).read)
    puts "MD5 hash of finalized DVI file still changes, giving up..."
  end
end


desc "Compare md5sum of #{FINALFILE.ext('dvi')} and #{MAINFILE.ext('dvi')}"
task :compare => [MAINFILE.ext("dvi")] + [FINALFILE.ext("dvi")] do
  # compare the integrated DVI to the MAINFILE DVI
  if Digest::MD5.digest(File.open(FINALFILE.ext("dvi")).read) == Digest::MD5.digest(File.open(MAINFILE.ext("dvi")).read)
    puts "----------------------------------------------------------------------------------"
    puts "| SUCCESS : The integrated DVI file is md5sum-identical to the original DVI file |"
    puts "----------------------------------------------------------------------------------"
  else
    puts "#####################################################################"
    puts "# ERROR : The integrated and the original DVI are different : ERROR #"
    puts "#####################################################################"
  end
end



file CONFERENCEEXPRESSFILE => @dvideps + [MAINFILE.ext("dvi")] do
  puts "Building Conference eXpress tarball"
  sh "tar czvf #{CONFERENCEEXPRESSFILE} #{MAINFILE.ext("dvi")} #{@dvideps.join(" ")}"
end


def tempfile_list
  Dir[File.join('**', '*~')] +
  Dir[File.join('**', '*.backup')] +
  Dir['*.aux'] +
  Dir[MAINFILE.ext("bbl")] +
  Dir[MAINFILE.ext("blg")] +
  Dir[MAINFILE.ext("dvi")] +
  Dir[MAINFILE.ext("log")] +
  Dir[MAINFILE.ext("out")] +
  Dir[MAINFILE.ext("pdf")] +
  Dir[MAINFILE.ext("ps")] +
  Dir[MAINFILE.ext("ps.gz")] +
  Dir[MAINFILE.ext("tpt")] +
  Dir[MAINFILE.ext("toc")] +
  Dir[MAINFILE.ext("lof")] +
  Dir[MAINFILE.ext("lot")] +
  Dir[MAINFILE.ext("loa")] +
  Dir[MAINFILE.ext("idx")] +
  Dir[MAINFILE.ext("ind")] +
  Dir[MAINFILE.ext("glo")] +
  Dir[MAINFILE.ext("ilg")] +
  Dir[MAINFILE.ext("nav")] +
  Dir[MAINFILE.ext("snm")] +
  Dir[MAINFILE.ext("nlo")] +
  Dir[MAINFILE.ext("nls")] +
  Dir[BOOKLETPSFILE] +
  Dir[FINALFILE.ext("dvi")] +
  Dir[FINALFILE.ext("log")] +
  Dir[FINALFILE.ext("out")] +
  Dir[FINALFILE.ext("pdf")] +
  Dir[FINALFILE.ext("ps")] +
  Dir[FINALFILE.ext("ps.gz")] +
  Dir[FINALFILE.ext("tpt")] +
  Dir[FINALFILE.ext("toc")] +
  Dir[FINALFILE.ext("lof")] +
  Dir[FINALFILE.ext("lot")] +
  Dir[FINALFILE.ext("idx")] +
  Dir[FINALFILE.ext("glo")] +
  Dir[FINALFILE.ext("nav")] +
  Dir[FINALFILE.ext("snm")] +
  Dir[FINALFILE.ext("tex")] +
  Dir["final_submission.tar.gz"] +
  Dir["conferenceexpress.tar.gz"]
end

def delete_if_exists(filename)
  if File.directory?(filename)
    if Dir[File.join(filename, "*")].size > 0
      puts "Cannot delete directory #{filename}: not empty"
    else
      puts "Deleting #{filename}"
      Dir.rmdir(filename)
    end
  elsif File.exists?(filename)
    puts "Deleting #{filename}"
    File.delete(filename)
  end
end

desc "Remove backups, temporary files,..."
task :clean do
  (tempfile_list + @cleanfiles).sort.each do |f|
    delete_if_exists(f)
  end
end


def all_file_prerequisites
  alldeps = []
  Rake::Task.tasks.each do |task|
    alldeps += task.prerequisites if task.kind_of?(Rake::FileTask)
  end
  return alldeps
end

def affected_dirs
  dirs = []
  all_file_prerequisites.collect do |dep|
    path = File.dirname(dep.to_s)
    while path != "."
      break if dirs.include?(path)
      dirs.push(path)
      path = File.dirname(dep.to_s)
    end
  end
  return dirs
end

def unknown_files
  ad = affected_dirs
  deps = Dir[File.join("**", "*")] -
         tempfile_list -
         @cleanfiles -
         ["Rakefile", "paper-build"] -
         all_file_prerequisites.collect { |t|  t.to_s }
  deps.uniq!
  deps.dup.each do |d|
    deps.delete(d) if ad.include?(d) or (File.dirname(d) != '.' and not ad.include?(File.dirname(d)))
  end
  return deps
end

desc "List unknown (spurious?) files"
task :unknown do
  puts
  puts 'The following files are not referenced in the LaTeX source and their purpose in unknown.'
  puts 'To delete these files use "rake clean_unknown". BE CAREFUL!'
  puts
  unknown_files.sort.each do |f|
    puts f
  end
end


desc "Delete unknown (spurious?) files (BE CAREFUL!)"
task :clean_unknown do
  unknown_files.sort.each do |f|
    delete_if_exists(f)
  end
end
